---
layout:     post
title:      【译】为什么Go可以有百万级别的Goroutine，但Java线程只能有上千个？
subtitle:   Goroutines & Threads
date:       2018-11-29
author:     Lvsi
header-img: 
catalog: true
tags:
    - 线程
    - Goroutine
---

## 【译】为什么Go可以有百万级别的Goroutine，但Java线程只能有上千个？

> 翻译文章来自 [《Why you can have millions of Goroutines but only thousands of Java Threads》](https://rcoh.me/posts/why-you-can-have-a-million-go-routines-but-only-1000-java-threads/)<br/>
> 补充翻译：[原文翻译](https://www.infoq.cn/article/a-million-go-routines-but-only-1000-java-threads)<br/>
> 译者：[Lvsi](https://github.com/Lvsi-China)

许多有经验的工程师在使用基于JVM的语言时，都会遇到过如下的错误：

```
[error] (run-main-0) java.lang.OutOfMemoryError: unable to create native thread: 
[error] java.lang.OutOfMemoryError: unable to create native thread: 
[error] 	at java.base/java.lang.Thread.start0(Native Method)
[error] 	at java.base/java.lang.Thread.start(Thread.java:813)
...
[error] 	at java.base/java.lang.Thread.run(Thread.java:844)
```

em...这是由于过多的线程造成 ```OutOfMemory```，在我的Linux笔记本上，才使用了 11500 个线程就出现这种错误了。

如果你在Go中做相同的事情，启动永久休眠状态的Goroutine，你会得到很不一样的结果。在我的笔记本上且在我实在是无聊之前，我已经创建了七千万个Goroutine。所以，为什么相比线程，可以创建这么多数量的Goroutine？要想知道答案，我们需要一直向底层沿着操作系统进行一次往返的旅行。这不仅是一个学术问题，它也影响着你对软件设计的理解。在生产环境中，我曾经多次遇到 JVM 线程的限制，有些是因为糟糕的代码导致线程泄露，有的则是因为一些工程师没有意识到 JVM 的线程限制。

## 到底什么是线程？

术语“线程”可以有很多种意思。在本文中，我会使用它来代指一个逻辑线程。也就是：按照线性顺序执行的一系列操作；一个执行的逻辑路径。CPU 的每个核心只能真正并发同时执行一个逻辑线程。这就造成一个固有的问题：如果线程的数量多于核心的数量，那么有的线程必须要暂停以便于其他的线程可以运行工作，当再次轮到执行自己的时候，任务就会恢复。为了支持暂停和恢复，线程至少需要如下两件事情：

1. 某种类型的指令指针。 即是，当我暂停的时候，我正在执行哪行代码？
2. 一个栈。即是，我当前的状态是什么？栈中包含了本地变量以及指向变量所分配的堆的指针。同一个进程中的所有线程共享相同的堆。

鉴于以上两点，系统在将线程调度到 CPU 上时就已经有了足够的信息去暂停某个线程，允许其他的线程运行，之后再次恢复原来暂停的线程。这种操作对线程来说通常是完全透明的。从线程的角度来说，它是连续运行的。线程能够感知到被重新调度的唯一方式是测量连续的操作之间的时间间隔。

回到我们最开始的那个问题：我们为什么能创建这么多的 Goroutines？

## JVM 使用的是操作系统的线程

尽管不是规范所要求的，但是据我所知所有的现代、通用 JVM 都将线程委托给了平台上的操作系统的线程来处理。在接下来的内容中，我将会使用“用户空间线程（user space thread）”来代指由语言进行调度的线程，而不是内核 /OS 所调度的线程。操作系统实现的线程有两个属性，这两个属性极大地限制了它们可以存在的数量；任何将语言线程和操作系统线程进行 1:1 映射的解决方案都无法支持大规模的并发。

### 在 JVM 中，固定大小的栈

#### 使用操作系统线程将会导致每个线程都有固定的、较大的内存成本

采用操作系统线程的另一个主要问题是每个 OS 线程都有大小固定的栈。尽管这个大小是可以配置的，但是在 64 位的环境中，JVM 会为每个线程分配 1M 的栈。你可以将默认的栈空间设置地更小一些，但是你需要权衡内存的使用，因为这会增加栈溢出的风险。代码中的递归越多，就越有可能出现栈溢出。如果你保持默认值的话，那么 1000 个线程就将使用 1GB 的 RAM。虽然现在 RAM 便宜了很多，但是几乎没有人会为了运行上百万个线程而准备 TB 级别的 RAM。

## Go 的不同之处：动态大小的栈

Golang 使用了一个非常聪明的技巧，防止系统因为运行大量的（大多数是未使用的）栈而耗尽内存：Go 的栈的大小是动态分配的，随着存储的数据的数量而增长或收缩。这并不是一件简单的事情，它的设计经历了多轮的迭代。我并不打算讲解内部的细节，但结论就是每个新建的 Goroutine 只有大约 4KB 的栈。每个栈只有 4KB，那么在一个 1GB 的 RAM 上，我们就可以有 250 万个 Goroutine 了，相对于 Java 中每个线程的 1MB，带来的提升是巨大的。

### 在 JVM 中：上下文切换的延迟

#### 从上下文切换有延迟的角度来说，使用操作系统线程只能有数万个线程

因为 JVM 使用了操作系统线程，所以依赖操作系统内核来调度它们。操作系统有一个所有正在运行的进程和线程的列表，并试图为它们分配“公平”的 CPU 运行时间。当内核从一个线程切换至另一个线程时，有很多的工作要做。新运行的线程和进程必须要将其他线程也在同一个 CPU 上运行的事实抽象出去。我不会在这里讨论细节问题，但是如果你对此感兴趣的话，可以阅读更多的资料。这里比较重要的就是，切换上下文要消耗 1 到 100 微秒。这看上去时间并不多，相对现实的情况是每次切换 10 微秒，如果你想要每秒钟内至少调度每个线程一次的话，那么每个核心上只能运行大约 10 万个线程。这实际上还没有给线程时间去执行有用的工作。

## Go 的不同之处：在一个操作系统线程上运行多个 Goroutines

Golang 实现了自己的调度器，允许众多的 Goroutines 运行在相同的 OS 线程上。就算 Go 会运行与内核相同的上下文切换，但是它能够避免切换至ring-0以运行内核，然后再切换回来，这样就会节省大量的时间。但是，这只是理论上的分析。为了支持上百万的 Goroutines，Go 需要完成更复杂的事情。

即使 JVM 将线程放到用户空间，它也无法支持上百万的线程。假设在按照这样设计的新系统中，新线程之间的切换只需要 100 纳秒。即便你所做的只是上下文切换，如果你想要每秒钟调度每个线程十次的话，你也只能运行大约 100 万个线程。更重要的是，为了完成这一点，我们需要最大限度地利用 CPU。要支持真正的大并发需要另外一项优化：当你知道线程能够做有用的工作时，才去调度它。如果你运行大量线程的话，其实只有少量的线程会执行有用的工作。Go 通过集成通道（channel）和调度器（scheduler）来实现这一点。如果某个 Goroutine 在一个空的通道上等待，那么调度器会看到这一点并且不会运行该 Goroutine。Go 更近一步，将大多数空闲的线程都放到它的操作系统线程上。通过这种方式，活跃的 Goroutine（预期数量会少得多）会在同一个线程上调度执行，而数以百万计的大多数休眠的 Goroutine 会单独处理。这样有助于降低延迟。

除非 Java 增加允许调度器观察的语言特性，否则，是不可能支持智能化调度的。但是，你可以在“用户空间”中构建运行时调度器，它能够感知到线程何时能够执行工作。这构成了像 Akka 这种能够支持上百万的 Actor的框架的基础.

## 结论

操作系统线程模型与轻量级、用户空间的线程模型之间在不断的发生转换，未来或许还会继续。对于高度并发的应用场景来说，这是唯一的选择。可是，它具有相当大的复杂性。如果 Go 选择使用 OS 线程而不是使用自己的调度器和递长的栈模式的话，那么Go的```runtime```中会减少数千行的代码。对于很多应用场景来说，这确实是更好的模型。复杂性可以被语言和库的编写者抽象出去，这样软件工程师就能编写大量并发的程序了。

## 补充
1. 超线程会将核心的效果加倍。指令流（instruction pipelining）也能增加 CPU 的并行效果。但是就当前来说，它还是 O(numCores)。
2. 可能在有些特殊场景中，这种说法是不正确的，我想肯定有人会提醒我这一点。
3. 这实际上是一种攻击。JavaScript 可以检测键盘中断所导致的在计时上的细微差别。恶意的站点用它来监听计时，而不是监听击键。参见：https://mlq.me/download/keystroke_js.pdf。
4. Golang 首先采用了一个分段的栈模型，在这个模型中，栈实际上会扩展至单独的内存区域，这个过程中使用非常聪明的记录功能进行跟踪。随后的实现在特定的场景下提升了性能，使用连续的栈来取代对栈的拆分，这很像对 hashtable 重新调整大小，分配一个新的更大的栈，并通过一些非常有技巧的指针操作，所有的内容都能够仔细地复制到新的、更大的栈中。
5. 线程可以通过调用nice来标记优先级，从而能够更好地控制它们调度的频率。
6. Actor 通过支持大规模并发，为 Scala/Java 实现了与 Goroutines 相同目的的特性。与 Goroutines 类似，Actor 调度器能够看到哪个 Actor 的收件箱中有消息，从而只运行那些能够执行真正有用工作的 Actor。我们所能拥有的 Actor 的数量甚至还能超过 Goroutines，因为 Actor 并不需要栈。但是，这也意味着，如果 Actor 无法快速处理消息的话，调度器将会阻塞（因为 Actor 没有自己的栈，所以它无法在 Actor 处理消息的过程中暂停）。阻塞的调度器意味着消息不能进行处理，系统很快会出现问题。这就是一种权衡。
7. 在 Apache 中，每个请求都由一个 OS 线程来处理，这限制了 Apache 只能有效的处理数千个并发连接。Nginx 选择了另外一种模型，一个 OS 线程能够应对上百个甚至上千的并发连接，从而允许了更高程度的并发。Erlang 使用了一个类似的模型，它允许数百万 Actor 并发执行。Gevent 为 Python 带来了 greenlet(用户空间线程)，它能够实现比以往更高程度的并发性 (Python 线程是 OS 线程)。